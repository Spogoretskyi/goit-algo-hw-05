## goit-algo-hw-04
# Набори даних:
Генератор генерує задану кількість унікальних елементів,
всього для замірів використав 4 набори даних з: 1 000, 10 000, 100 000, 1 000 000 елементів 

# Заміри:
| Алгоритм        |Часова складність    | 1 000               | 10 000            | 100 000         | 1 000 000        |
|-----------------|---------------------|---------------------|-------------------|-----------------|-------------------
| Timsort(sorted) | O(n log n)          | 0.0010468930000     | 0.014070553999    | 0.39002582700   | 1.6143088259     |
| Timsort(sort)   | O(n log n)          | 0.0010030549999     | 0.011508411999    | 0.15278346799   | 1.3773102830     |
| Merge           | O(n log n)          | 0.0083616059999     | 0.090778323999    | 0.99687819600   | 10.975302990     |
| Insertion       | O(n^2)              | 0.0874846069999     | 11.04756530000    | 528.187136292   | 2 hours <        |

# Різниця між Timsort (sorted) та Timsort (sort):
це однаковий алгоритм, але: функція `sorted()` приймає ітерабельний об'єкт (наприклад, список, кортеж, рядок) і повертає новий список, який містить відсортовані елементи вхідного об'єкта.
Вихідний об'єкт залишається незмінним. Оригінальний список залишається в тому порядку, в якому він був переданий.
Можливість використання на будь-якому ітерабельному об'єкті.

Метод `sort()` викликається на об'єкті списку і змінює його напряму. Він не створює нового списку.
Не повертає значення (або повертає None), тому його не можна використовувати виразно.
Використовується тільки для списків.

# Висновок
Порівнявши всі заміри, як ми бачимо, найшвидший алгоритм серед порівнюваних є `Timsort`
Також можна підтвердити, що складність алгоритму `Insertion` є квадратною, це можна побачити на великих наборах даних. На наборі в 1 000 000 елементів, 
відпрацьовувало більше 2 годин, поки примусово не зупинив процес. Тобто можна зробити висновок, що вбудований алгноритм сортування у `Python` є дуже ефективни в порівнянні з іншими.  
